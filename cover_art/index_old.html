<hmtl>

<head>
	<script src="https://d3js.org/d3.v4.min.js"></script>
</head>

<body>
	<script>
		//Load data and call visualization function in callbacks (whatever the fuck those are)
		d3.tsv("node_data.tsv", function(node_error,nodes){
			if(node_error) throw node_error;

			d3.tsv("edge_list.tsv", function(edge_error,edges){
				if(edge_error) throw edge_error;

				create_viz(nodes, edges);
				});
		});
		
		//Use to scale numbers
		function getRandomArbitrary(min, max) {
		  return Math.random() * (max - min) + min;
		}

		//Build out a color
		function getHue(lower, upper, split){
			var rand_color = Math.random(); 
			var hue;
			if (rand_color > split){
				hue = upper;
			} else {
				hue = lower;
			}
			return hue;
		}

		function create_timepoint(g, structure, edges, width, height, lscale, max_depth){
			for(var i=0; i<4;i++){
				var G=g.append('g').attr('transform', "rotate(180,"+width/4+","+height/4+") rotate("+i*90+")")

				var jittered=structure[i];

				// Add edges
				G.append('g').selectAll('path')
					.data(edges).enter().append("path")//.filter(function(d){return (d.parent_depth<max_depth && d.child_depth<max_depth);})
						.attr('id', function(d){return d.parent+"_"+d.child;})
						.attr("d", function(d){
							var parent=jittered[Number(d.parent)];
							var child=jittered[Number(d.child)];
							return "M "+parent.scaled_cx*width/2+","+parent.scaled_cy*width/2+" L "+child.scaled_cx*width/2+","+child.scaled_cy*width/2;
						})
						.attr("opacity", function(d){if((Math.abs(max_depth-d.parent_depth)>1)||(Math.abs(max_depth-d.child_depth)>1)){op=0.3;}else{op=1;} return op;})
						.attr('stroke-width', function(d){return Math.max(0.5, 1*Math.random());})
						.attr('stroke', '#FFF')

				// Set hue range properly
				var upper_hue;
				var lower_hue;
				var split = 0.1;
				if (i===0 || i===2){
					upper_hue = 220;
					lower_hue = 310;

				} else if (i===1 || i===3){
					upper_hue = 310;
					lower_hue = 220;
				}

				var rad = d3.scaleLinear().domain([1,8]).range([2,5]);


				// Add nodes
				G.append('g').selectAll("circle")
					.data(jittered).enter().append('circle')//.filter(function(d){return d.depth<max_depth})
						.attr('id', function(d){return "node_"+d.node;})
						.attr("cx", function(d){return Number(d.scaled_cx)*width/2;})
						.attr("cy", function(d){return Number(d.scaled_cy)*width/2;})
						.attr("r", function(d){return rad(d.degree)})	
						.attr("opacity", function(d){if(Math.abs(max_depth-d.depth)>1){op=0.1;}else{op=1;} return op;})
						.attr('fill', function(d){return d3.color("hsl("+getHue(lower_hue, upper_hue, split)+","+"50%,"+lscale(d.depth)+"%)");})
						.attr('stroke', "#222");
			}

		}

		function create_viz(nodes, edges){
			// Print the data to the console

			// Make an SVG with specified dimensions in pixels
			var width=790/96*72;
			var height=850/96*72;
			var margin=10; //{top: 10, left:20};


			var svg=d3.select("body").append("svg").attr("width", width+2*margin).attr("height", height+2*margin);
			
			svg.append('rect').attr("width", width+2*margin).attr("height", height+2*margin).attr('fill', '#222').attr('stroke', '#F00');
			svg = svg.append('g').attr('transform', 'translate(10,10)');

			// Add border to svg for easy viewing
			svg.append('rect').attr("width", width).attr("height", height).attr('fill', "#222").attr('stroke', '#00F');

			// Set node 0 to center of canvas
			// var X=nodes[0].scaled_cx;
			// var Y=nodes[0].scaled_cy;

			// Make and store the original structure
			var structure=[];

			var timepoint = svg.append('g')
			for(var i=0; i<4;i++){
				// Add jitter
				var jittered=nodes;
				for (var jj=0; jj<nodes.length;jj++){
					jittered[jj].scaled_cx*=getRandomArbitrary(0.95, 1.05);
					jittered[jj].scaled_cy*=getRandomArbitrary(0.95, 1.05);
					jittered[jj].scaled_cx=Math.min(1, jittered[jj].scaled_cx);
					jittered[jj].scaled_cy=Math.min(1, jittered[jj].scaled_cy);
				}

				structure.push(jittered);
			}
			
			//Stacked
			// var counter=8;
			// var stack_height = height/2;
			// var stack_width = width/2;
			// for (var cc=counter; cc>0; cc--){
			// 	console.log(cc, [Math.max(0,cc-3), cc, Math.min(cc+3)]);
			// 	if (cc===1){
			// 		lscale = d3.scaleLinear().domain([0, 0]).range([50, 50]);
			// 		// console.log(lscale(0));
			// 	} else {
			// 		lscale = d3.scaleLinear().domain([Math.max(0,cc-3), cc, Math.min(cc+3)]).range([80, 50, 80]);
			// 	}
			// 	var x_translate = stack_width/(counter-1)*(counter-cc);
			// 	var y_translate = stack_height/(counter-1)*(counter-cc);
			// 	svg.append('rect')
			// 		.attr('width', stack_width)
			// 		.attr("height", stack_height)
			// 		.attr('fill', '#555')
			// 		.attr('opacity', 0)
			// 		.attr('transform', "translate("+x_translate+","+y_translate+")");
			// 	create_timepoint(svg.append('g').attr('transform', "translate("+x_translate+","+y_translate+")"), structure, edges, stack_width, stack_height, lscale, cc);
			// }

			//Paneled
			var rows = 3;
			var cols = 3;
			var idx = 0;
			for(var row=0; row<rows; row++){
				for(var col=0; col<cols; col++){
					x_offset = col*width/cols;
					y_offset = row*height/rows;
					console.log(x_offset, y_offset)
					// svg.append('rect')
					// 	.attr('width', width/cols)
					// 	.attr("height", height/rows)
					// 	.attr('fill', '#333')
					// 	// .attr('opacity', idx/rows/cols)
					// 	.attr('transform', "translate("+x_offset+","+y_offset+")");
					idx+=1;
					// // Set the lightness scale
					// var lscale;
					// if (xx===0 && yy===0){
					// 	lscale = d3.scaleLinear().domain([0,3]).range([50, 100]);
					// } else if (xx===1 && yy===0){
					// 	lscale = d3.scaleLinear().domain([0,2,4,5]).range([80, 80, 50, 100]);
					// } else if (xx===0 && yy===1){
					// 	lscale = d3.scaleLinear().domain([0,2,4,7]).range([100, 80, 50, 100]);
					// } else if (xx===1 && yy===1){	
					// 	lscale = d3.scaleLinear().domain([3, 4,8]).range([100, 50, 100]);
					// }				
					var lscale = d3.scaleLinear().domain([0,3]).range([50, 100]);
					// // var lscale = d3.scaleLinear().domain([0,6,8]).range([100, 50, 100]);
					lscale = d3.scaleLinear().domain([Math.max(0,idx-3), idx, Math.min(idx+3)]).range([80, 50, 80]);
					
					create_timepoint(svg.append('g').attr('transform', "translate("+x_offset+","+y_offset+")"), structure, edges, width/cols, height/rows, lscale, idx);


				}
			}

		}
			
	</script>
</body>

</hmtl>
